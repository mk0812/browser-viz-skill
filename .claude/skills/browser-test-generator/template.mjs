/**
 * Browser Test Template
 * Generated by browser-test-generator skill
 *
 * Test: {{TEST_NAME}}
 * Description: {{TEST_DESCRIPTION}}
 * URL: {{TEST_URL}}
 */
import { spawn } from 'child_process';
import { mkdir, writeFile, readFile } from 'fs/promises';
import { existsSync } from 'fs';

// =============================================================================
// Configuration
// =============================================================================
const TEST_NAME = '{{TEST_SLUG}}';
const TEST_URL = '{{TEST_URL}}';
const OUTPUT_DIR = './test-output';
const FRAMES_DIR = `${OUTPUT_DIR}/${TEST_NAME}-frames`;

let frameCounter = 0;

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Execute agent-browser command
 */
async function agentBrowser(command, args = []) {
  return new Promise((resolve, reject) => {
    const proc = spawn('agent-browser', [command, ...args]);
    let stdout = '';
    let stderr = '';

    proc.stdout.on('data', (data) => {
      stdout += data.toString();
    });
    proc.stderr.on('data', (data) => {
      stderr += data.toString();
    });

    proc.on('close', (code) => {
      if (code === 0) {
        resolve(stdout.trim());
      } else {
        reject(new Error(stderr || `Command failed with code ${code}`));
      }
    });
  });
}

/**
 * Take screenshot with frame numbering
 */
async function screenshot(name, description = '') {
  frameCounter++;
  const filename = `${FRAMES_DIR}/${String(frameCounter).padStart(3, '0')}-${name}.png`;
  await agentBrowser('screenshot', [filename]);
  console.log(`üì∏ [${frameCounter}] ${name}: ${description || 'captured'}`);
  return filename;
}

/**
 * Sleep for specified milliseconds
 */
async function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Get current page snapshot (interactive elements)
 */
async function getSnapshot() {
  return await agentBrowser('snapshot', ['-i']);
}

/**
 * Add highlight (red frame) to screenshot using sharp
 */
async function addHighlight(imagePath, box, outputPath) {
  const sharp = (await import('sharp')).default;

  const image = sharp(imagePath);
  const metadata = await image.metadata();

  const padding = 5;
  const x = Math.max(0, box.x - padding);
  const y = Math.max(0, box.y - padding);
  const width = Math.min(metadata.width - x, box.width + padding * 2);
  const height = Math.min(metadata.height - y, box.height + padding * 2);

  const svg = `
    <svg width="${metadata.width}" height="${metadata.height}">
      <rect
        x="${x}" y="${y}"
        width="${width}" height="${height}"
        fill="none" stroke="#FF0000" stroke-width="3" rx="4" ry="4"
      />
    </svg>
  `;

  await image
    .composite([{ input: Buffer.from(svg), top: 0, left: 0 }])
    .toFile(outputPath);

  return outputPath;
}

/**
 * Take screenshot with highlight
 */
async function screenshotWithHighlight(name, box, description = '') {
  const rawPath = await screenshot(`${name}-raw`, description);
  const highlightedPath = rawPath.replace('-raw.png', '.png');
  await addHighlight(rawPath, box, highlightedPath);
  console.log(`üî¥ Highlighted: ${highlightedPath}`);
  return highlightedPath;
}

/**
 * Generate GIF from frames using ffmpeg
 */
async function generateGif(outputName, options = {}) {
  const {
    fps = 3,
    scale = '640:-1',
    quality = 'normal' // 'normal' or 'high'
  } = options;

  const inputPattern = `${FRAMES_DIR}/%03d-*.png`;
  const outputPath = `${OUTPUT_DIR}/${outputName}`;

  // Build filter based on quality
  let filter;
  if (quality === 'high') {
    filter = `fps=${fps},scale=${scale}:flags=lanczos,split[s0][s1];[s0]palettegen=max_colors=256:stats_mode=full[p];[s1][p]paletteuse=dither=sierra2_4a`;
  } else {
    filter = `fps=${fps},scale=${scale}:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse`;
  }

  return new Promise((resolve, reject) => {
    // Get list of frames for ffmpeg
    const { readdirSync } = require('fs');
    const frames = readdirSync(FRAMES_DIR)
      .filter(f => f.endsWith('.png') && !f.includes('-raw'))
      .sort();

    if (frames.length === 0) {
      reject(new Error('No frames found'));
      return;
    }

    // Create concat file for ffmpeg
    const concatFile = `${FRAMES_DIR}/concat.txt`;
    const concatContent = frames
      .map(f => `file '${f}'\nduration ${1/fps}`)
      .join('\n');

    require('fs').writeFileSync(concatFile, concatContent);

    const proc = spawn('ffmpeg', [
      '-y',
      '-f', 'concat',
      '-safe', '0',
      '-i', concatFile,
      '-vf', filter,
      '-loop', '0',
      outputPath
    ]);

    proc.on('error', reject);
    proc.on('close', (code) => {
      if (code === 0) {
        console.log(`üé¨ GIF saved: ${outputPath}`);
        resolve(outputPath);
      } else {
        reject(new Error(`ffmpeg exited with code ${code}`));
      }
    });
  });
}

/**
 * Alternative GIF generation using image sequence
 */
async function generateGifFromSequence(outputName, fps = 3) {
  const { readdirSync } = await import('fs');
  const frames = readdirSync(FRAMES_DIR)
    .filter(f => f.endsWith('.png') && !f.includes('-raw'))
    .sort()
    .map(f => `${FRAMES_DIR}/${f}`);

  if (frames.length === 0) {
    throw new Error('No frames found');
  }

  const outputPath = `${OUTPUT_DIR}/${outputName}`;

  return new Promise((resolve, reject) => {
    const proc = spawn('ffmpeg', [
      '-y',
      '-framerate', String(fps),
      '-pattern_type', 'glob',
      '-i', `${FRAMES_DIR}/*.png`,
      '-vf', `fps=${fps},scale=640:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse`,
      '-loop', '0',
      outputPath
    ]);

    let stderr = '';
    proc.stderr.on('data', (data) => {
      stderr += data.toString();
    });

    proc.on('error', reject);
    proc.on('close', (code) => {
      if (code === 0) {
        console.log(`üé¨ GIF saved: ${outputPath}`);
        resolve(outputPath);
      } else {
        reject(new Error(`ffmpeg failed: ${stderr}`));
      }
    });
  });
}

// =============================================================================
// Test Steps
// =============================================================================

async function main() {
  console.log('='.repeat(60));
  console.log(`Test: {{TEST_NAME}}`);
  console.log(`URL: ${TEST_URL}`);
  console.log('='.repeat(60));

  // Setup output directories
  await mkdir(FRAMES_DIR, { recursive: true });

  // Open browser
  console.log('\nüìÇ Opening browser...');
  await agentBrowser('open', [TEST_URL, '--headed']);
  await sleep(500);

  // {{TEST_STEPS}}

  // Generate GIF
  console.log('\nüé¨ Generating GIF...');
  try {
    await generateGifFromSequence(`${TEST_NAME}.gif`, 2);
  } catch (e) {
    console.warn('GIF generation failed:', e.message);
  }

  console.log('\n‚úÖ Test completed!');
  console.log(`Output: ${OUTPUT_DIR}/${TEST_NAME}-frames/`);
}

main().catch((error) => {
  console.error('‚ùå Test failed:', error.message);
  process.exit(1);
});
